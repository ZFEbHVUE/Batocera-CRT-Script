#!/bin/bash
# batocera-resolution (patched)
#
# Key changes:
# - If /etc/switchres.ini has monitor=custom, we DO NOT touch monitor nor crt_range0..9.
# - If monitor is NOT custom (e.g., arcade_15/25/31...), we derive one range for the mode
#   and apply it to ALL crt_range0..9 during the run so switchres can't mix ranges; then we restore.
# - Geometry from videomodes.conf (-g) is honored because we avoid conflicting range mixes.
# - currentMode: Returns full videomodes.conf ID (e.g., 769x576.50.00060) instead of
#   truncated xrandr format, allowing ES to correctly display VIDEO MODE selection.
#
# NOTE: defineMode path kept as-is (no temp ini injection) per user's request to handle later.

log="/userdata/system/logs/display.log"
mpvlog="/userdata/system/logs/mpv.log"
BOOTCONF="/boot/batocera-boot.conf"

# --- Clean up previous switchres modeline - start ---
STATE_FILE="/tmp/switchres-last-resolution-state"
if [ -f "$STATE_FILE" ]; then
    read -r LAST_OUTPUT LAST_MODE < "$STATE_FILE"
    CURRENT_MODE=$(xrandr --verbose | awk -v out="$LAST_OUTPUT" '
        $0 ~ "^"out {found=1}
        found && / connected/ {found=0}
        found && /[0-9]+x[0-9]+/ && /\*/ {print $1; exit}
    ')
    if [ "$CURRENT_MODE" = "$LAST_MODE" ]; then
        echo "[batocera-resolution] Skipping deletion of $LAST_MODE because it is currently active on $LAST_OUTPUT" >> "$log"
    elif xrandr | grep -q "$LAST_MODE"; then
        echo "[batocera-resolution] Deleting modeline $LAST_MODE from output $LAST_OUTPUT" >> "$log"
        xrandr --delmode "$LAST_OUTPUT" "$LAST_MODE"
    else
        echo "[batocera-resolution] Previous modeline $LAST_MODE not found, skipping deletion" >> "$log"
    fi
    rm -f "$STATE_FILE"
fi
# --- Clean up previous switchres modeline - end ---

PSCREEN=
if test "${1}" = "--screen"; then
    shift
    PSCREEN=$1
    shift
fi

# set default screen, the first one
if test -z "${PSCREEN}"; then
    PSCREEN=$(xrandr --listPrimary)
fi

f_usage() {
    echo "${0} listModes" >&2
    echo "${0} setMode <MODE>" >&2
    echo "${0} currentMode" >&2
    echo "${0} currentResolution" >&2
    echo "${0} listOutputs" >&2
    echo "${0} currentOutput" >&2
    echo "${0} setOutput <output>" >&2
    echo "${0} minTomaxResolution" >&2
    echo "${0} minTomaxResolution-secure" >&2
    echo "${0} setDPI" >&2
    echo "${0} forceMode <horizontal>x<vertical>:<refresh>" >&2
    echo "${0} setRotation (0|1|2|3)" >&2
    echo "${0} getRotation" >&2
    echo "${0} getDisplayMode" >&2
    echo "${0} refreshRate" >&2
}

f_minTomaxResolution() {
    BOOTRESOLUTION="$(batocera-settings-get -f "$BOOTCONF" es.resolution)"
    CONFRESOLUTION="$(batocera-settings-get-master es.resolution)"

    if [ -z "$1" ]; then
        # reinit the screen (in case it was off)
        if [ -n "${BOOTRESOLUTION}" ] && [ "${BOOTRESOLUTION}" != "auto" ]; then
            BOOT_RES=$(echo "${BOOTRESOLUTION}" | cut -d'.' -f1)
            BOOT_RATE=$(echo "${BOOTRESOLUTION}" | cut -s -d'.' -f2-)
            if [ -n "$BOOT_RATE" ]; then
                echo "es.resolution setting found. Initializing screen to: ${BOOT_RES} @ ${BOOT_RATE}Hz" >> "$log"
                xrandr --output "${PSCREEN}" --mode "${BOOT_RES}" --rate "${BOOT_RATE}"
            else
                echo "es.resolution setting found. Initializing screen to: ${BOOT_RES}" >> "$log"
                xrandr --output "${PSCREEN}" --mode "${BOOT_RES}"
            fi
        else
            # No global setting or it's 'auto'. Re-initialize with --auto.
            echo "No specific resolution requested, re-initializing screen with --auto" >> "$log"
            xrandr --output "${PSCREEN}" --auto
        fi
    fi

    CURRENT_RESOLUTION=$(xrandr --currentResolution "${PSCREEN}")
    CURRENTWIDTH=$(echo "${CURRENT_RESOLUTION}" | cut -d x -f 1)
    CURRENTHEIGHT=$(echo "${CURRENT_RESOLUTION}" | cut -d 'x' -f 2)
    CURRENTRATE=$(xrandr --listModes "${PSCREEN}" | grep -E '\*$' | sed -E 's/.* ([0-9]+\.[0-9]+)\*?.*/\1/')
    CURRENT_ROTATION=$(xrandr --currentRotation "${PSCREEN}" | cut -c1)
    echo "Current resolution: $CURRENTWIDTH x $CURRENTHEIGHT @ $CURRENTRATE Hz" >> "$log"
    echo "Current rotation: ${CURRENT_ROTATION}" >> "$log"

    MWIDTH=$(echo "$1"x | tr -d '[:blank:]' | cut -dx -f1) # the final added x is for compatibility with v29
    MHEIGHT=$(echo "$1"x | tr -d '[:blank:]' | cut -dx -f2)

    # This logic finds the highest resolution with the highest refresh rate >= 59Hz.
    IDEAL_MODE_INFO=$(xrandr --listModes "${PSCREEN}" | \
        awk '/^[0-9]+x[0-9]+/ {if ($NF ~ /\*/) {print $1, $2, $NF; exit}}')

    if [ -n "$IDEAL_MODE_INFO" ]; then
        IDEAL_WIDTH=$(echo "$IDEAL_MODE_INFO" | awk '{print $1}')
        IDEAL_HEIGHT=$(echo "$IDEAL_MODE_INFO" | awk '{print $2}')
        IDEAL_RATE=$(echo "$IDEAL_MODE_INFO" | awk '{print $3}' | tr -d '*')
        echo "Auto-detected ideal mode: ${IDEAL_WIDTH}x${IDEAL_HEIGHT} @ ${IDEAL_RATE}Hz" >> "$log"
    else
        echo "Could not find any ideal mode with a refresh rate >= 59Hz." >> "$log"
    fi

    # Priority selection
    if [ -n "$MWIDTH" ] && [ -n "$MHEIGHT" ] && [ "$MWIDTH" -ne 0 ] && [ "$MHEIGHT" -ne 0 ]; then
        echo "Requested: $MWIDTH x $MHEIGHT" >> "$log"
        MAXWIDTH="$MWIDTH"
        MAXHEIGHT="$MHEIGHT"
    elif [ -n "${BOOTRESOLUTION}" ]; then
        RESOLUTION=$(echo "$BOOTRESOLUTION" | sed 's/max-//;s/\..*//')
        MAXWIDTH=$(echo "$RESOLUTION" | cut -d 'x' -f 1)
        MAXHEIGHT=$(echo "$RESOLUTION" | cut -d 'x' -f 2)
        MAXRATE=$(echo "$BOOTRESOLUTION" | cut -s -d '.' -f 2-)
        if [ -n "$MAXRATE" ]; then
            echo "Using ES resolution setting of $MAXWIDTH x $MAXHEIGHT @ $MAXRATE Hz" >> "$log"
        else
            echo "Using ES resolution setting of $MAXWIDTH x $MAXHEIGHT" >> "$log"
        fi
    elif [ -n "${CONFRESOLUTION}" ]; then
        RESOLUTION=$(echo "$CONFRESOLUTION" | sed 's/max-//;s/\..*//')
        MAXWIDTH=$(echo "$RESOLUTION" | cut -d 'x' -f 1)
        MAXHEIGHT=$(echo "$RESOLUTION" | cut -d 'x' -f 2)
        MAXRATE=$(echo "$CONFRESOLUTION" | cut -s -d '.' -f 2-)
        if [ -n "$MAXRATE" ]; then
            echo "Using master ES resolution setting of $MAXWIDTH x $MAXHEIGHT @ $MAXRATE Hz" >> "$log"
        else
            echo "Using master ES resolution setting of $MAXWIDTH x $MAXHEIGHT" >> "$log"
        fi
    elif [ -n "$IDEAL_WIDTH" ]; then
        ROUNDED_CURRENTRATE=$(printf "%.0f\n" "${CURRENTRATE}")
        if [ "$ROUNDED_CURRENTRATE" -eq 60 ]; then
            echo "Current refresh rate is ${CURRENTRATE}Hz (~60Hz). Keeping current resolution." >> "$log"
            MAXWIDTH=$CURRENTWIDTH
            MAXHEIGHT=$CURRENTHEIGHT
            MAXRATE=$CURRENTRATE
        else
            echo "Using ideal resolution: $IDEAL_WIDTH x $IDEAL_HEIGHT @ $IDEAL_RATE Hz" >> "$log"
            MAXWIDTH=$IDEAL_WIDTH
            MAXHEIGHT=$IDEAL_HEIGHT
            MAXRATE=$IDEAL_RATE
        fi
    else
        if [ -f "$mpvlog" ]; then
            selected_mode=$(grep -oE '\[.*\] Selected mode: .* \(([^)]+)\)' "$mpvlog" | awk -F '[()]' '{print $2}')
            MAXWIDTH=$(echo "$selected_mode" | cut -d 'x' -f 1)
            MAXHEIGHT=$(echo "$selected_mode" | cut -d 'x' -f 2 | cut -d '@' -f 1)
            MAXRATE=$(echo "$selected_mode" | cut -d '@' -f 2 | sed 's/Hz//' | xargs)
            echo "MPV default drm resolution setting of $MAXWIDTH x $MAXHEIGHT @ $MAXRATE Hz" >> "$log"
        fi
    fi

    if [ -n "$MAXWIDTH" ] && [ -n "$MAXHEIGHT" ] && [ "$MAXWIDTH" -ne 0 ] && [ "$MAXHEIGHT" -ne 0 ]; then
        if [ -n "$MAXRATE" ]; then
            echo "Resolution to use: $MAXWIDTH x $MAXHEIGHT @ $MAXRATE Hz" >> "$log"
        else
            echo "Resolution to use: $MAXWIDTH x $MAXHEIGHT" >> "$log"
        fi
    else
        echo "No resolution set, nothing to do..." >> "$log"
        exit 0
    fi

    TARGET_WIDTH=$MAXWIDTH
    TARGET_HEIGHT=$MAXHEIGHT
    if [ "${CURRENT_ROTATION}" = "1" ] || [ "${CURRENT_ROTATION}" = "3" ]; then
        TARGET_WIDTH=$MAXHEIGHT
        TARGET_HEIGHT=$MAXWIDTH
    fi

    if [ "$CURRENTWIDTH" -eq "$TARGET_WIDTH" ] && [ "$CURRENTHEIGHT" -eq "$TARGET_HEIGHT" ]; then
        if [ -z "$MAXRATE" ] || [ "$(printf "%.2f" "${CURRENTRATE}")" = "$(printf "%.2f" "${MAXRATE}")" ]; then
            echo "We have a match, nothing to do..." >> "$log"
            if [ "${CURRENT_ROTATION}" != "0" ]; then
                batocera-resolution --screen "${PSCREEN}" setRotation "${CURRENT_ROTATION}"
            fi
            exit 0
        fi
    fi

    if [ -n "$MAXRATE" ]; then
        xrandr --listModes "${PSCREEN}" | while IFS= read -r line; do
            resolution=$(echo "$line" | awk -F'.' '{print $1}')
            rate=$(echo "$line" | grep -oE '[0-9]+\.[0-9]+' | tail -1 | tr -d "*")
            if echo "$resolution" | grep -q "^${MAXWIDTH}x${MAXHEIGHT}" && [ "$rate" = "$MAXRATE" ]; then
                echo "Found & using matching resolution: $line" >> "$log"
                PARTRES=$(echo "$line" | awk -F'.' '{print $1}')
                OUTPUT=${PSCREEN}
                echo "New resolution applied = Output: ${OUTPUT} Resolution: ${PARTRES} Rate: ${MAXRATE}" >> "$log"
                xrandr --output "$OUTPUT" --mode "$PARTRES" --rate "${MAXRATE}"
                if [ "${CURRENT_ROTATION}" != "0" ]; then
                    batocera-resolution --screen "${PSCREEN}" setRotation "${CURRENT_ROTATION}"
                fi
                exit 0
            fi
        done
    else
        xrandr --listModes "${PSCREEN}" | while read SUGGRESOLUTIONRATE SUGGMODE; do
            SUGGRESOLUTION=$(echo "${SUGGRESOLUTIONRATE}" | cut -d . -f 1)
            SUGGWIDTH=$(echo "${SUGGRESOLUTION}" | cut -d x -f 1)
            SUGGHEIGHT=$(echo "${SUGGRESOLUTION}" | cut -d x -f 2)
            if test "${SUGGWIDTH}" -le "${MAXWIDTH}" -a "${SUGGHEIGHT}" -le "${MAXHEIGHT}"; then
                OUTPUT=${PSCREEN}
                echo "Using old method = Output: ${OUTPUT} Mode: ${SUGGRESOLUTION}" >> "$log"
                xrandr --output "${OUTPUT}" --mode "${SUGGRESOLUTION}"
                if [ "${CURRENT_ROTATION}" != "0" ]; then
                    batocera-resolution --screen "${PSCREEN}" setRotation "${CURRENT_ROTATION}"
                fi
                exit 0
            fi
        done
    fi
}

if [ $# -eq 0 ]; then
    f_usage
    exit 1
fi

ACTION=$1
shift


# --- helpers: whitelist-aware mode selection ---
is_mode_in_videomodes_conf() {
  local m="$1" f
  for f in /userdata/system/videomodes.conf /userdata/system/configs/videomodes.conf; do
    [ -s "$f" ] || continue
    awk -v M="$m" 'NF && $0 !~ /^[[:space:]]*#/ { if ($0==M) { found=1; exit } } END { exit !found }' "$f"
    if [ $? -eq 0 ]; then return 0; fi
  done
  return 1
}

_parse_wxh_rr() {
  local s="$1"
  if [[ "$s" =~ ^([0-9]+)x([0-9]+)\.([0-9.]+)$ ]]; then
    echo "${BASH_REMATCH[1]} ${BASH_REMATCH[2]} ${BASH_REMATCH[3]}"
    return 0
  fi
  return 1
}

_set_mode_from_videomodes_conf() {
  local token="$1" out="${PSCREEN}"
  if [[ "$token" == BOOT_* ]]; then
    # defer to existing BOOT handler if present
    true
  fi
  local W H RR
  if read -r W H RR < <(_parse_wxh_rr "$token"); then
    xrandr --output "$out" --mode "${W}x${H}" --rate "$RR" 2>/dev/null && return 0
    xrandr --output "$out" --mode "${W}x${H}" 2>/dev/null && return 0
    if command -v switchres >/dev/null 2>&1; then
      switchres -k -f "${W}x${H}@${RR}" >/dev/null 2>&1 || true
      xrandr --output "$out" --mode "${W}x${H}" --rate "$RR" 2>/dev/null && return 0
    fi
    return 1
  fi
  if [[ "$token" =~ ^([0-9]+)x([0-9]+)$ ]]; then
    xrandr --output "$out" --mode "$token"
    return $?
  fi
  return 1
}


case "${ACTION}" in
    "listModes")
        # STRICT: only list modes explicitly present in videomodes.conf
        VMFILE=""
        for f in /userdata/system/videomodes.conf /userdata/system/configs/videomodes.conf; do
          if [ -s "$f" ]; then VMFILE="$f"; break; fi
        done
        if [ -n "$VMFILE" ]; then
          # Print non-empty, non-comment lines exactly as written
          awk 'NF && $0 !~ /^[[:space:]]*#/ { sub(/[[:space:]]+$/, "", $0); print }' "$VMFILE"
        else
          # Fallback for safety: if no videomodes.conf, show what the driver reports
          xrandr --listModes "${PSCREEN}" | sed -e 's/\*$//' | sed -e 's/^\([^ ]*\) \(.*\)$/\1:\2/' | sed -e "/\b\(SR\)\b/d"
        fi
    ;;

    "setMode")
        MODE_Search=$1
        MODE=$(echo $MODE_Search | sed 's/.\{3\}$//')
        OUTPUT="$PSCREEN"

        source /usr/bin/get_monitorRange
        file="/userdata/system/videomodes.conf"
        log_file_monitor="/userdata/system/logs/BootRes.log"
        Switchres_file="/etc/switchres.ini"

        # Helper: set all crt_range0..9 to a single range for the active mode
        set_all_crt_ranges() {
          # $1 = ini path, $2 = range text to set (single-line)
          local ini="$1"
          local rng="$2"
          local i
          for i in $(seq 0 9); do
            if grep -qE "^[[:space:]]*crt_range${i}[[:space:]]+" "$ini"; then
              sed -i "s|^[[:space:]]*crt_range${i}[[:space:]]\+.*|    crt_range${i}              ${rng}|" "$ini"
            else
              printf '\tcrt_range%s              %s\n' "$i" "$rng" >> "$ini"
            fi
          done
        }

        info_game="/userdata/system/logs/info_game"

        read WIDTH HEIGHT PARTHZ <<< $(echo $MODE | awk -F'[x.]' '{print $1, $2, $3 "." $4}')
        line=$(grep -F "$MODE_Search" "$file")

        IFS=' :'
        read Active_res Resolution H_size H_shift V_shift Hfreq Vfreq <<< "$line"
        Vfreq=$(echo "$7" | tr -d '\r\n')
        unset IFS

        Monitor_name=$(awk '/Monitor Type:/{print $3}' "$log_file_monitor")
        Monitor_custom=$(grep -v "^#" "$Switchres_file" | grep "monitor" | head -1 | awk '{print $2}')
        Monitor_default="custom"

        # Backup all crt_rangeN entries (0–9)
        declare -A crt_ranges_backup
        for i in {0..9}; do
            range=$(grep -oP "^\s*crt_range${i}\s+\K.*" "$Switchres_file")
            if [[ -n "$range" ]]; then
                crt_ranges_backup[$i]="$range"
            fi
        done

        # Temporarily set monitor to "custom" (so SR reads from crt_range* only)
        sed -i "s/.*monitor        .*/    monitor              $Monitor_default/" "$Switchres_file"

        # Mirror existing ranges into explicit crt_rangeN lines (they might be 'auto')
        for i in "${!crt_ranges_backup[@]}"; do
            if grep -q "^[[:space:]]*crt_range${i}[[:space:]]\+" "$Switchres_file"; then
                sed -i "s|^\s*crt_range${i}\s\+.*|   crt_range${i}              ${crt_ranges_backup[$i]}|" "$Switchres_file"
            else
                echo -e "\tcrt_range${i}              ${crt_ranges_backup[$i]}" >> "$Switchres_file"
            fi
        done

        # If the active INI already says monitor=custom, DO NOT override user's crt_range0..9
        if [[ "$Monitor_custom" == "custom" ]]; then
            echo "[INFO] monitor=custom — preserving user-defined crt_range0–crt_range9 from switchres.ini" >> "$log"
        else
            # Only when monitor is not custom, derive a single range and apply to all slots
            crt_range_setmode=$(get_monitorRange "$Monitor_name" "$Hfreq" "$Vfreq")
            set_all_crt_ranges "$Switchres_file" "$crt_range_setmode"
        fi

        DOTCLOCK_MAX=25.0
        DOTCLOCK_MIN=$(grep -v "^#" /etc/switchres.ini | grep "dotclock_min" | head -1 | awk '{print $2}')
        if (( $(echo "$DOTCLOCK_MIN >= $DOTCLOCK_MAX" | bc -l) )); then
            sed -i "s/.*dotclock_min        .*/     dotclock_min              0/" "$Switchres_file"
        fi

        game_switchres=$(switchres ${WIDTH} ${HEIGHT} ${PARTHZ} -s -k -f ${WIDTH}x${HEIGHT}@${PARTHZ} -g "${H_size}:${H_shift}:${V_shift}")

        # Log newly generated modeline for future cleanup
        NEW_MODE=$(xrandr | grep 'SR-1_' | awk '{print $1}' | tail -n1)
        if [ -n "$NEW_MODE" ] && [ -n "$OUTPUT" ]; then
            echo "$OUTPUT $NEW_MODE" > /tmp/switchres-last-resolution-state
            echo "[batocera-resolution] Stored modeline state: $NEW_MODE on $OUTPUT" >> "$log"
        fi

        # Restore monitor and dotclock_min
        sed -i "s/.*monitor        .*/    monitor              $Monitor_custom/" "$Switchres_file"
        sed -i "s/.*dotclock_min        .*/    dotclock_min              $DOTCLOCK_MIN/" "$Switchres_file"

        # Restore all crt_range0–9
        for i in "${!crt_ranges_backup[@]}"; do
            sed -i "s|^[[:space:]]*crt_range${i}[[:space:]]\+.*|    crt_range${i}              ${crt_ranges_backup[$i]}|" "$Switchres_file"
        done

        cp "$Switchres_file" /userdata/system/logs/Switchres_game.ini
        [ -f "$info_game" ] && rm "$info_game"
        {
            echo "Information for the last game"
            echo "Resolution of research=$MODE_Search"
            echo "Resolution_input=$MODE"
            echo "WIDTH=$WIDTH HEIGHT=$HEIGHT PARTHZ=$PARTHZ"
            echo "line of videomodes=$line"
            echo "Active_res=$Active_res Resolution=$Resolution  H_size=$H_size  H_shift=$H_shift V_shift=$V_shift Hfreq=$Hfreq Vfreq=$Vfreq"
            echo "Monitor_name=$Monitor_name"
            echo "Monitor for ES=$Monitor_custom"
            echo "crt_range for game (applied when non-custom) = $crt_range_setmode"
            echo "Monitor use for game = $Monitor_default"
            echo "Dotclock_min use for game=$DOTCLOCK_MIN"
            echo "game_switchres=$game_switchres"
        } > "$info_game"
    ;;

    "defineMode")
        MODE=$1
        read WIDTH HEIGHT PARTHZ <<< $(echo $MODE | awk -F'[x.]' '{print $1, $2, $3 "." $4}')
        RES_MODE="${WIDTH}x${HEIGHT}"
        DOTCLOCK_MIN=$(grep -v "^#" /etc/switchres.ini | grep "dotclock_min" | head -1 | awk '{print $2}')
        DOTCLOCK_MIN_SWITCHRES=0
        sed -i "s/.*dotclock_min        .*/     dotclock_min              $DOTCLOCK_MIN_SWITCHRES/" /etc/switchres.ini
        MODE_xrandr=$(switchres  ${WIDTH} ${HEIGHT} ${PARTHZ} -f ${WIDTH}x${HEIGHT}@${PARTHZ} -i switchres.ini -c)
        sed -i "s/.*dotclock_min        .*/     dotclock_min              $DOTCLOCK_MIN/" /etc/switchres.ini

        MODELINE_CUSTOM=$(echo "$MODE_xrandr" | sed -n 's/.*Modeline "[^"]*" \([0-9.]\+\) \([0-9 ]\+\) \(.*\)/\1 \2 \3/p')
        OUTPUT="$PSCREEN"
        xrandr -display :0.0 --newmode ${RES_MODE} ${MODELINE_CUSTOM}
        xrandr -display :0.0 --addmode ${OUTPUT} ${RES_MODE}
    ;;

    "setMode_CVT")
        MODE=$1
# If this exact token is whitelisted in videomodes.conf, do NOT use CVT.
if is_mode_in_videomodes_conf "$MODE"; then
    if _set_mode_from_videomodes_conf "$MODE"; then
        echo "setMode_CVT bypassed; used whitelisted mode: $MODE" >> "$log"
        exit 0
    else
        echo "Whitelisted token present but failed to set via xrandr: $MODE" >> "$log"
        # fall through to original CVT logic as a last resort
    fi
fi

        echo "setMode: ${MODE}" >> "$log"
        if echo "${MODE}" | grep -qE 'max-'; then
            CURRENT_ROTATION=$(xrandr --currentRotation "${PSCREEN}" | cut -c1)
            if test "${CURRENT_ROTATION}" = 1 -o "${CURRENT_ROTATION}" = 3; then
                SPMODE=$(echo "${MODE}" | sed -e 's/^max-\([0-9]*\)x\([0-9]*\)$/\2x\1/')
            else
                SPMODE=$(echo "${MODE}" | sed -e 's/^max-//')
            fi
            echo "f_minTomaxResolution: $SPMODE" >> "$log"
            f_minTomaxResolution "${SPMODE}"
        else
            CURRENT_ROTATION=$(xrandr --currentRotation "${PSCREEN}" | cut -c1)
            OUTPUT=${PSCREEN}
            if [ -z "$OUTPUT" ]; then
                echo "No connected output detected" >> "$log"
                exit 1
            fi
            if echo "${MODE}" | grep "\." >/dev/null; then
                PARTRES=$(echo "${MODE}" | cut -d'.' -f1)
                PARTHZ=$(echo "${MODE}" | cut -d'.' -f2-)
                echo "setMode: Output: ${OUTPUT} Resolution: ${PARTRES} Rate: ${PARTHZ}" >> "$log"
                xrandr --output "${OUTPUT}" --mode "${PARTRES}" --rate "${PARTHZ}"
                if [ "${CURRENT_ROTATION}" != "0" ]; then
                    batocera-resolution --screen "${PSCREEN}" setRotation "${CURRENT_ROTATION}"
                fi
            else
                echo "setMode: Output: ${OUTPUT} Mode: ${MODE}" >> "$log"
                xrandr --output "${OUTPUT}" --mode "${MODE}"
                if [ "${CURRENT_ROTATION}" != "0" ]; then
                    batocera-resolution --screen "${PSCREEN}" setRotation "${CURRENT_ROTATION}"
                fi
            fi
            if [ $? -ne 0 ]; then
                echo "Failed to set display mode" >> "$log"
                exit 1
            fi
        fi
    ;;

    "currentMode")
        # Get the xrandr mode name (e.g., "769x576.50.00")
        XRANDR_MODE=$(xrandr --listModes "${PSCREEN}" | grep -E '\*$' | sed -e 's/\*$//' -e 's/^\([^ ]*\) .*/\1/')
        
        # Try to find the full mode ID in videomodes.conf (needed for ES VIDEO MODE display)
        VMFILE=""
        for f in /userdata/system/videomodes.conf /userdata/system/configs/videomodes.conf; do
            [ -s "$f" ] && VMFILE="$f" && break
        done
        
        if [ -n "$VMFILE" ] && [ -n "$XRANDR_MODE" ]; then
            # Look for entry where mode ID (minus last 3 chars) matches xrandr mode
            # Hardened: Skip empty lines, comments, and guard substr() for short mode_ids
            FULL_MODE=$(awk -F: -v xm="$XRANDR_MODE" '
                NF && $0 !~ /^[[:space:]]*#/ {  # Skip empty lines and comments
                    mode_id=$1
                    # Guard substr() call - only if mode_id length > 3
                    if (length(mode_id) > 3) {
                        short_id=substr(mode_id, 1, length(mode_id)-3)
                        if (short_id == xm) {print mode_id; exit}
                    }
                }' "$VMFILE")
            
            if [ -n "$FULL_MODE" ]; then
                echo "$FULL_MODE"
            else
                echo "$XRANDR_MODE"  # Fallback to xrandr mode
            fi
        else
            echo "$XRANDR_MODE"  # Fallback to xrandr mode
        fi
    ;;

    "refreshRate")
        xrandr --listModes "${PSCREEN}" | grep -E '\*$' | sed -e 's/\*$//' -e 's/^\([^ ]*\) .*/\1/' | awk -F'[.]' '{print $2 "." $3}'
    ;;

    "currentResolution")
        xrandr --currentResolution "${PSCREEN}" | tail -n1
    ;;

    "listOutputs")
        xrandr --listConnectedOutputs | sed -e 's/*$//'
    ;;

    "currentOutput")
        echo "${PSCREEN}"
    ;;

    "setOutput")
        MODE1=$1
        MODE2=$2
        MODE3=$3
        if xrandr --listConnectedOutputs | sed -e 's/*$//' | grep -qE "^${MODE1}$"; then
            xrandr --listConnectedOutputs | sed -e 's/*$//' | grep -vE "^${MODE1}$|^${MODE2}$|^${MODE3}$" | while read OUTP; do
                echo "set ${OUTP} off" >&2
                xrandr --output "${OUTP}" --off
            done
            echo "set user output: ${MODE1} as primary" >&2 >> "$log"
            xrandr --output "${MODE1}" --primary
            PREVIOUS_SCREEN="${MODE1}"
            if test -n "${MODE2}"; then
                if xrandr --listConnectedOutputs | sed -e 's/*$//' | grep -qE "^${MODE2}$"; then
                    echo "set user output: ${MODE2} as right of ${PREVIOUS_SCREEN}" >&2 >> "$log"
                    xrandr --output "${MODE2}" --right-of "${PREVIOUS_SCREEN}"
                    PREVIOUS_SCREEN="${MODE2}"
                fi
            fi
            if test -n "${MODE3}"; then
                if xrandr --listConnectedOutputs | sed -e 's/*$//' | grep -qE "^${MODE3}$"; then
                    echo "set user output: ${MODE3} as right of ${PREVIOUS_SCREEN}" >&2 >> "$log"
                    xrandr --output "${MODE3}" --right-of "${PREVIOUS_SCREEN}"
                    PREVIOUS_SCREEN="${MODE3}"
                fi
            fi
        else
            xrandr --listConnectedOutputs | sed -e 's/*$//' | (
                read FIRSTOUTPUT
                while read OUTP; do
                    echo "set ${OUTP} off" >&2
                    xrandr --output "${OUTP}" --off
                done
                echo "set ${FIRSTOUTPUT} as primary" >&2 >> "$log"
                xrandr --output "${FIRSTOUTPUT}" --primary
            )
        fi
    ;;

    "minTomaxResolution" | "minTomaxResolution-secure")
        f_minTomaxResolution "$1"
    ;;

    "setDPI")
        xrandr --dpi $1
    ;;

    "forceMode")
        REQUESTED=$1
        H=$(echo "$REQUESTED" | sed "s/\([0-9]*\)x.*/\1/")
        V=$(echo "$REQUESTED" | sed "s/.*x\([0-9]*\).*/\1/")
        R=$(echo "$REQUESTED" | grep : | sed "s/.*:\([0-9]*\)/\1/")
        if [ z"$H" != z  ] && [ z"$V" != z ]; then
            if [ z"$R" != z ]; then
                MODELINE=$(cvt "$H" "$V" "$R")
            else
                MODELINE=$(cvt "$H" "$V")
            fi
        else
            >&2 echo "error: invalid mode ${REQUESTED}" >> "$log"
        fi
        MODE=$(echo "$MODELINE" | egrep -v "^#" | tail -n 1 | sed "s/^Modeline //")
        MNAME=$(echo "$MODE" | cut -d' ' -f1)
        OUTPUT=${PSCREEN}
        xrandr --newmode ${MODE}
        xrandr --addmode "${OUTPUT}" "${MNAME}"
        xrandr --output "${OUTPUT}" --mode "${MNAME}"
    ;;

    "supportSystemRotation")
        exit 0
    ;;

    "supportSystemReflection")
        exit 0
    ;;

    "setRotation")
        TRIES=5
        COUNT=0
        ROTATE=$1
        OUTPUT=${PSCREEN}
        while [ $COUNT -lt $TRIES ]; do
            TOUCHSCREEN=$(xinput | grep pointer | tail -n +2 | grep -Ei 'touchscreen|2808:1015|27C6:011A|0603:F001|HID Touch' | sed -E 's/[^a-zA-Z0-9]*((\S+ ?)+[a-zA-Z0-9\(\)]+)\s*id=([0-9]+)\s*(.*)/"\1"/')
            TOUCHID=$(xinput | grep pointer | tail -n +2 | grep -Ei 'touchscreen|2808:1015|27C6:011A|0603:F001|HID Touch' | sed -E 's/[^a-zA-Z0-9]*((\S+ ?)+[a-zA-Z0-9\(\)]+)\s*id=([0-9]+)\s*(.*)/\3/')
            if [ -n "$TOUCHSCREEN" ] && [ -n "$TOUCHID" ]; then
                echo "Touch screen panel: $TOUCHSCREEN" >> "$log"
                echo "With touch screen panel ID of: $TOUCHID" >> "$log"
                break
            fi
            COUNT=$((COUNT+1))
            sleep 1
        done

        case "${ROTATE}" in
            "1")
                xrandr --output "${OUTPUT}" --rotate right
                [ ! -z "${TOUCHSCREEN}" ] && xinput set-prop "${TOUCHID}" --type=float "Coordinate Transformation Matrix" 0 1 0 -1 0 1 0 0 1
                echo "Screen rotated right" >> "$log"
            ;;
            "2")
                xrandr --output "${OUTPUT}" --rotate inverted
                [ ! -z "${TOUCHSCREEN}" ] && xinput set-prop "${TOUCHID}" --type=float "Coordinate Transformation Matrix" -1 0 1 0 -1 1 0 0 1
                echo "Screen rotated inverted" >> "$log"
            ;;
            "3")
                xrandr --output "${OUTPUT}" --rotate left
                [ ! -z "${TOUCHSCREEN}" ] && xinput set-prop "${TOUCHID}" --type=float "Coordinate Transformation Matrix" 0 -1 1 1 0 0 0 0 1
                echo "Screen rotated left" >> "$log"
            ;;
            *)
                xrandr --output "${OUTPUT}" --rotate normal
                [ ! -z "${TOUCHSCREEN}" ] && xinput set-prop "${TOUCHID}" --type=float "Coordinate Transformation Matrix" 1 0 0 0 1 0 0 0 1
        esac
    ;;

    "getRotation")
        xrandr --currentRotation "${PSCREEN}"
    ;;

    "setReflection")
        OUTPUT=${PSCREEN}
        REFLECTION=$1
        xrandr --output "${OUTPUT}" --reflect "${REFLECTION}"
    ;;

    "getDisplayMode")
        echo "xorg"
    ;;

    *)
        f_usage
        >&2 echo "error: invalid command ${ACTION}"
        exit 1
    ;;
esac
